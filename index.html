<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerichte ‚Äì Client & Admin (Single File)</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --accent: #22d3ee;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --ok: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(1200px 800px at 10% 10%, #0b1226 0, var(--bg) 60%);
      color: var(--text);
    }
    .wrap { max-width: 1000px; margin: 0 auto; padding: 24px; }
    header {
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
      margin-bottom: 16px;
    }
    .brand { font-weight: 700; letter-spacing: .2px; display: flex; gap: 10px; align-items: center;}
    .brand-badge {
      width: 28px; height: 28px; border-radius: 8px; background: linear-gradient(135deg, #22d3ee, #22c55e);
      box-shadow: 0 0 20px rgba(34, 211, 238, .35);
    }
    nav { display: flex; gap: 8px; }
    a.btn {
      text-decoration: none; color: var(--text);
      padding: 10px 14px; border-radius: 12px; background: #0b1220; border: 1px solid #1f2a44;
    }
    a.btn.active, a.btn:hover { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(34,211,238,.15) inset; }
    .panel {
      background: linear-gradient(180deg, var(--panel) 0, var(--panel-2) 100%);
      border: 1px solid #243048; border-radius: 16px; padding: 18px; margin: 12px 0;
      box-shadow: 0 10px 30px rgba(2,6,23,.35);
    }
    h1,h2,h3 { margin: 6px 0 10px; }
    h1 { font-size: 26px; }
    h2 { font-size: 20px; color: var(--accent); }
    .grid { display: grid; gap: 14px; }
    @media (min-width: 900px) { .grid-2 { grid-template-columns: 1fr 1fr; } }
    label { font-size: 14px; color: var(--muted); display:block; margin-bottom:6px; }
    input, textarea, select {
      width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid #2a385a;
      background: #0b1220; color: var(--text); outline: none;
    }
    textarea { min-height: 72px; resize: vertical; }
    .row { display: flex; gap: 10px; }
    .row > * { flex: 1; }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    button {
      padding: 10px 14px; border-radius: 12px; border: 1px solid #2a385a;
      background: #0b1220; color: var(--text); cursor: pointer;
    }
    button.primary { border-color: var(--accent); }
    button.ok { border-color: var(--ok); }
    button.warn { border-color: var(--warn); }
    button.danger { border-color: var(--danger); }
    .muted { color: var(--muted); font-size: 14px; }
    .list { display: grid; gap: 10px; }
    .item {
      display: grid; gap: 6px; padding: 12px; border: 1px solid #25314c; border-radius: 14px;
      background: #0b1220;
    }
    .item-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .badge {
      padding: 4px 8px; border-radius: 999px; border: 1px solid #2a385a; font-size: 12px;
    }
    .badge.ok { border-color: var(--ok); background: rgba(34,197,94,0.06); }
    .badge.warn { border-color: var(--warn); background: rgba(245,158,11,0.06); }
    .badge.danger { border-color: var(--danger); background: rgba(239,68,68,0.06); }
    .empty {
      padding: 16px; border: 1px dashed #2a385a; border-radius: 12px; color: var(--muted);
      text-align: center;
    }
    .footer { margin-top: 24px; color: var(--muted); font-size: 12px; text-align: center; }
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .dish-checkbox-row { display:flex; align-items:center; gap:10px; padding:8px; border-radius:10px; background:transparent; border:1px solid transparent; }
    .dish-checkbox-row input[type="checkbox"] { width:18px; height:18px; }
    .dish-checkbox-row label { cursor:pointer; }
    ul.inline-list { margin:0; padding-left:18px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="brand-badge" aria-hidden="true"></div>
        <div>
          <div style="font-size:14px;color:var(--muted)">Single-File App</div>
          <div style="font-size:18px">Gerichte ‚Äì Client & Admin</div>
        </div>
      </div>
      <nav>
        <a href="#/client" id="link-client" class="btn">Client</a>
        <a href="#/admin" id="link-admin" class="btn">Admin</a>
      </nav>
    </header>

    <!-- Client View -->
    <section id="view-client" class="panel" hidden>
      <h1>Bestellung aufgeben</h1>
      <div class="grid grid-2">
        <div class="panel">
          <h2>1) Gerichte w√§hlen</h2>
          <div id="client-dish-picker"></div>
        </div>
        <div class="panel">
          <h2>2) Name</h2>
          <form id="order-form">
            <label for="customer-name">Name</label>
            <input id="customer-name" name="customer-name" placeholder="Max Mustermann" required />
            <div class="actions" style="margin-top:10px">
              <button class="primary" type="submit">Bestellen</button>
              <button type="reset" id="order-reset-btn">Zur√ºcksetzen</button>
            </div>
            <div class="hint">Nach Absenden erscheint deine Bestellung im Admin-Bereich.</div>
          </form>
        </div>
      </div>
    </section>

    <!-- Admin View -->
    <section id="view-admin" class="panel" hidden>
      <h1>Admin</h1>
      <div class="grid grid-2">
        <div class="panel">
          <h2>Gerichte verwalten</h2>
          <form id="dish-form">
            <label for="dish-name">Gericht</label>
            <input id="dish-name" placeholder="z. B. Spaghetti Bolognese" required />
            <div class="row">
              <div>
                <label for="dish-price">Preis (‚Ç¨)</label>
                <input id="dish-price" type="number" step="0.01" min="0" placeholder="9.90" />
              </div>
              <div>
                <label for="dish-tags">Tags (optional)</label>
                <input id="dish-tags" placeholder="vegan, scharf, ..."/>
              </div>
            </div>
            <label for="dish-desc">Beschreibung (optional)</label>
            <textarea id="dish-desc" placeholder="Kurzbeschreibung..."></textarea>
            <div class="actions" style="margin-top:10px">
              <button class="primary" type="submit">Gericht anlegen</button>
              <button type="button" id="seed-btn">Demo-Daten f√ºllen</button>
              <button class="warn" type="button" id="clear-dishes-btn">Alle Gerichte l√∂schen</button>
            </div>
          </form>

          <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
            <button id="export-dishes-btn">Gerichte exportieren</button>
            <button id="import-dishes-btn">Gerichte importieren</button>
            <input id="import-dishes-file" type="file" accept="application/json" style="display:none" />
            <div class="muted" style="align-self:center; font-size:13px;">Export/Import synchronisiert manuell zwischen Ger√§ten.</div>
          </div>

          <div id="dish-list" class="list" style="margin-top:10px"></div>
        </div>
        <div class="panel">
          <h2>Eingehende Bestellungen (letzte 48 Stunden)</h2>
          <div class="actions" style="margin-bottom:8px">
            <button class="warn" id="clear-done-btn" type="button">Erledigte entfernen</button>
            <button class="danger" id="clear-orders-btn" type="button">Alle Bestellungen l√∂schen</button>
          </div>
          <div id="order-list" class="list"></div>
          <div class="hint">Admin aktualisiert Bestellungen automatisch (Polling). Bestellungen werden remote in JSONBin gespeichert.</div>
        </div>
      </div>
    </section>

    <div class="footer">
      Routen: <code>#/client</code> und <code>#/admin</code> ‚Ä¢ Single File ‚Ä¢ GitHub Pages kompatibel
    </div>
  </div>

  <script>
    // -------------------- CONFIG --------------------
    const REMOTE_SYNC_DISHES = true;
    const REMOTE_SYNC_ORDERS = true;
    const JSONBIN_KEY = "$2a$10$N/2gxnECUzbO8QCffVQ7Ye6N5Oare5DGjQCPaTkkcovABoafVICSS";
    const JSONBIN_DISHES_ID = "68a5d4feae596e708fcf10d3";
    const JSONBIN_ORDERS_ID = "68a5e44a43b1c97be9236b9e";
    const POLL_INTERVAL_MS = 10000; // Increased to reduce network load
    // ------------------------------------------------

    // Cached DOM elements
    const domCache = {
      clientDishPicker: null,
      orderForm: null,
      customerName: null,
      dishForm: null,
      dishName: null,
      dishPrice: null,
      dishDesc: null,
      dishTags: null,
      dishList: null,
      orderList: null,
      viewClient: null,
      viewAdmin: null,
      linkClient: null,
      linkAdmin: null
    };

    // Initialize DOM cache
    function initDomCache() {
      domCache.clientDishPicker = document.getElementById("client-dish-picker");
      domCache.orderForm = document.getElementById("order-form");
      domCache.customerName = document.getElementById("customer-name");
      domCache.dishForm = document.getElementById("dish-form");
      domCache.dishName = document.getElementById("dish-name");
      domCache.dishPrice = document.getElementById("dish-price");
      domCache.dishDesc = document.getElementById("dish-desc");
      domCache.dishTags = document.getElementById("dish-tags");
      domCache.dishList = document.getElementById("dish-list");
      domCache.orderList = document.getElementById("order-list");
      domCache.viewClient = document.getElementById("view-client");
      domCache.viewAdmin = document.getElementById("view-admin");
      domCache.linkClient = document.getElementById("link-client");
      domCache.linkAdmin = document.getElementById("link-admin");
    }

    // Performance-optimized element creation
    function createEl(tag, attrs = {}, ...children) {
      const n = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") n.className = v;
        else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
        else if (v !== undefined && v !== null) n.setAttribute(k, v);
      }
      for (const c of children) n.append(c instanceof Node ? c : document.createTextNode(c));
      return n;
    }

    const uid = () => Math.random().toString(36).slice(2,10) + Date.now().toString(36);

    // ---------- local storage helpers ----------
    function getDishesLocal() { 
      try { 
        const cached = localStorage.getItem("app.dishes.v1");
        return cached ? JSON.parse(cached) : []; 
      } catch(e) { 
        return []; 
      } 
    }
    
    function setDishesLocal(a) { 
      localStorage.setItem("app.dishes.v1", JSON.stringify(a)); 
    }
    
    function getOrdersLocal() { 
      try { 
        const cached = localStorage.getItem("app.orders.v1");
        return cached ? JSON.parse(cached) : []; 
      } catch(e) { 
        return []; 
      } 
    }
    
    function setOrdersLocal(a) { 
      localStorage.setItem("app.orders.v1", JSON.stringify(a)); 
    }

    // ---------- JSONBin helpers ----------
    async function fetchBinLatest(binId) {
      if(!binId) return null;
      const url = `https://api.jsonbin.io/v3/b/${binId}/latest`;
      const h = { "X-Master-Key": JSONBIN_KEY };
      const res = await fetch(url, { headers: h });
      if(!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();
      return json.record;
    }
    
    async function putBin(binId, data) {
      if(!binId) throw new Error("no bin id");
      const url = `https://api.jsonbin.io/v3/b/${binId}`;
      const headers = { "Content-Type":"application/json", "X-Master-Key": JSONBIN_KEY, "X-Bin-Versioning": "false" };
      const res = await fetch(url, { method: "PUT", headers, body: JSON.stringify(data) });
      if(!res.ok) {
        const t = await res.text().catch(()=>"");
        throw new Error("HTTP " + res.status + " " + t);
      }
      return await res.json();
    }

    // ---------- Normalizer for orders (accept many shapes) ----------
    function normalizeOrders(raw) {
      let arr = null;
      if(!raw) return [];
      if(Array.isArray(raw)) arr = raw;
      else if(typeof raw === "object") {
        const keys = Object.keys(raw);
        if(Array.isArray(raw.orders)) arr = raw.orders;
        else if(Array.isArray(raw.data)) arr = raw.data;
        else if(Array.isArray(raw.items)) arr = raw.items;
        else {
          for(const k of keys) {
            if(Array.isArray(raw[k])){ arr = raw[k]; break; }
          }
        }
        if(arr === null) arr = [raw];
      } else {
        return [];
      }

      const normalized = arr.map((o) => {
        if(!o || typeof o !== 'object') return null;
        
        let customerName = o.customerName || o.name || o.customer || (o.customer && (o.customer.name||o.customer.customerName)) || "";
        if(typeof customerName === 'object') { 
          customerName = customerName.name || customerName.customerName || "";
        }
        
        let destination = o.destination || o.address || o.wohin || (o.customer && o.customer.address) || "N/A";
        if(typeof destination === 'object') destination = JSON.stringify(destination);
        
        let items = o.dishes || o.items || o.products || o.orderItems || [];
        if(!Array.isArray(items)) {
          if(typeof items === 'object') {
            const possible = Object.values(items).find(v=>Array.isArray(v));
            items = possible || [];
          } else {
            items = [];
          }
        }
        
        const normItems = items.map(it => {
          if(!it) return null;
          if(typeof it === 'string') return { name: it, price: 0 };
          if(typeof it === 'object') {
            const name = it.name || it.title || it.item || it.product || "";
            const price = (isFinite(Number(it.price))? Number(it.price) : (isFinite(Number(it.cost))?Number(it.cost):0));
            return { name: name || JSON.stringify(it).slice(0,40), price };
          }
          return null;
        }).filter(Boolean);

        let id = o.id || o._id || o.orderId || (o.customer && o.customer.id) || null;
        if(!id) id = uid();
        
        let status = (o.status || o.state || o.orderStatus || "open") + "";
        status = status.toLowerCase();
        if(status === "in_arbeit" || status === "in arbeit" || status === "inprogress" || status === "in progress" || status === "in_progress" || status === "processing") status = "in_progress";
        else if(status === "done" || status === "erledigt" || status === "completed" || status === "finished") status = "done";
        else status = "open";

        let createdAt = o.createdAt || o.timestamp || o.time || o.created_at || o.date || new Date().toISOString();
        try { if(typeof createdAt === 'number') createdAt = new Date(createdAt).toISOString(); else createdAt = new Date(createdAt).toISOString(); } catch(e){ createdAt = new Date().toISOString(); }

        return {
          id: String(id),
          customerName: String(customerName || "").trim(),
          destination: String(destination || "").trim(),
          dishes: normItems,
          status,
          createdAt
        };
      }).filter(Boolean);

      return normalized;
    }

    // ---------- update helpers (local + optional remote) ----------
    async function updateDishes(arr, pushRemote = true) {
      setDishesLocal(arr);
      if(REMOTE_SYNC_DISHES && pushRemote) {
        try{ 
          await putBin(JSONBIN_DISHES_ID, arr); 
        } catch(e){ 
          console.warn("putBin dishes failed", e); 
          // Only show alert on critical failure, not on every error
        }
      }
    }
    
    async function updateOrders(arr, pushRemote = true) {
      setOrdersLocal(arr);
      if(REMOTE_SYNC_ORDERS && pushRemote) {
        try{ 
          await putBin(JSONBIN_ORDERS_ID, arr); 
        } catch(e){ 
          console.warn("putBin orders failed", e); 
          // Only show alert on critical failure, not on every error
        }
      }
    }

    // ---------- rendering / UI logic (keeps layout) ----------
    function renderClient() {
      const dishes = getDishesLocal();
      if(!dishes.length) { 
        domCache.clientDishPicker.innerHTML = '<div class="empty">Noch keine Gerichte verf√ºgbar. Bitte Admin fragen, welche anzulegen.</div>';
        return; 
      }
      
      // Use DocumentFragment for better performance
      const fragment = document.createDocumentFragment();
      
      for(const d of dishes) {
        const row = createEl("div",{class:"dish-checkbox-row"});
        const cb = createEl("input",{type:"checkbox", value:d.id, id:"dish-"+d.id});
        const label = createEl("label",{for:"dish-"+d.id}, `${d.name}${d.price?` ‚Äì ${d.price.toFixed(2)} ‚Ç¨`:""}`);
        row.appendChild(cb);
        row.appendChild(label);
        fragment.appendChild(row);
        
        if(d.desc) {
          const descEl = createEl("div",{class:"muted", style:"font-size:13px;margin-left:28px;"}, d.desc);
          fragment.appendChild(descEl);
        }
      }
      
      domCache.clientDishPicker.innerHTML = '';
      domCache.clientDishPicker.appendChild(fragment);
    }

    // dish management (same UI)
    domCache.dishForm.addEventListener("submit", async e => {
      e.preventDefault();
      const name = domCache.dishName.value.trim();
      const price = parseFloat(domCache.dishPrice.value);
      const desc = domCache.dishDesc.value.trim();
      const tags = domCache.dishTags.value.trim();
      if(!name) { alert("Gerichtsname erforderlich."); return; }
      const arr = getDishesLocal();
      const existing = arr.findIndex(x => x.name.toLowerCase() === name.toLowerCase());
      if(existing >= 0) {
        arr[existing] = { id: arr[existing].id || uid(), name, price: isFinite(price)?price:0, desc, tags };
      } else {
        arr.unshift({ id: uid(), name, price: isFinite(price)?price:0, desc, tags });
      }
      await updateDishes(arr, true);
      e.target.reset();
      renderDishList();
      renderClient();
    });
    
    document.getElementById("seed-btn").addEventListener("click", async () => { 
      const local = getDishesLocal(); 
      if(local.length) return; 
      const demo = [
        {id:uid(),name:"Margherita",price:7.5,desc:"Tomate, Mozzarella, Basilikum",tags:"vegetarisch"},
        {id:uid(),name:"Spaghetti Bolognese",price:9.9,desc:"Hausgemachte So√üe",tags:""},
        {id:uid(),name:"Rotes Thai Curry",price:11.5,desc:"Mit Gem√ºse & Kokos",tags:"scharf,vegan"}
      ]; 
      await updateDishes(demo,true); 
      renderDishList(); 
      renderClient(); 
    });
    
    document.getElementById("clear-dishes-btn").addEventListener("click", async () => { 
      if(confirm("Alle Gerichte wirklich l√∂schen?")){ 
        await updateDishes([], true); 
        renderDishList(); 
        renderClient(); 
      } 
    });

    function renderDishList() {
      const arr = getDishesLocal();
      if(!arr.length) { 
        domCache.dishList.innerHTML = '<div class="empty">Keine Gerichte vorhanden.</div>';
        return; 
      }
      
      // Use DocumentFragment for better performance
      const fragment = document.createDocumentFragment();
      
      for(const d of arr) {
        const item = createEl("div",{class:"item"},
          createEl("div",{class:"item-header"}, 
            createEl("strong",{}, d.name), 
            createEl("div",{}, d.price ? createEl("span",{class:"badge"}, `${d.price.toFixed(2)} ‚Ç¨`) : "")
          ),
          d.desc ? createEl("div",{class:"muted"}, d.desc) : "",
          d.tags ? createEl("div",{class:"muted"}, `Tags: ${d.tags}`) : "",
          createEl("div",{class:"actions"}, 
            createEl("button",{class:"primary", onclick: async () => { editDish(d.id); }}, "Bearbeiten"),
            createEl("button",{class:"danger", onclick: async () => { await deleteDish(d.id); }}, "L√∂schen")
          )
        );
        fragment.appendChild(item);
      }
      
      domCache.dishList.innerHTML = '';
      domCache.dishList.appendChild(fragment);
    }
    
    async function deleteDish(id) { 
      const remaining = getDishesLocal().filter(d=>d.id!==id); 
      await updateDishes(remaining, true); 
      renderDishList(); 
      renderClient(); 
    }
    
    async function editDish(id) {
      const dishes = getDishesLocal();
      const dish = dishes.find(d => d.id === id);
      if(!dish) return;
      
      domCache.dishName.value = dish.name;
      domCache.dishPrice.value = dish.price || "";
      domCache.dishDesc.value = dish.desc || "";
      domCache.dishTags.value = dish.tags || "";
      
      domCache.dishForm.scrollIntoView({ behavior: "smooth" });
      
      const form = domCache.dishForm;
      const originalSubmit = form.onsubmit;
      
      form.onsubmit = async function(e) {
        e.preventDefault();
        const name = domCache.dishName.value.trim();
        const price = parseFloat(domCache.dishPrice.value);
        const desc = domCache.dishDesc.value.trim();
        const tags = domCache.dishTags.value.trim();
        if(!name) { alert("Gerichtsname erforderlich."); return; }
        
        const arr = getDishesLocal();
        const existingIndex = arr.findIndex(x => x.id === id);
        if(existingIndex >= 0) {
          arr[existingIndex] = { id: dish.id, name, price: isFinite(price)?price:0, desc, tags };
        }
        await updateDishes(arr, true);
        form.reset();
        renderDishList();
        renderClient();
        
        form.onsubmit = originalSubmit;
      };
    }

    // export/import dishes
    document.getElementById("export-dishes-btn").addEventListener("click", () => { 
      const data = getDishesLocal(); 
      const blob = new Blob([JSON.stringify(data,null,2)],{type:"application/json"}); 
      const url = URL.createObjectURL(blob); 
      const a = document.createElement("a"); 
      a.href = url; 
      a.download = "gerichte_export_"+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')+".json"; 
      document.body.appendChild(a); 
      a.click(); 
      a.remove(); 
      URL.revokeObjectURL(url); 
    });
    
    document.getElementById("import-dishes-btn").addEventListener("click", () => document.getElementById("import-dishes-file").click());
    
    document.getElementById("import-dishes-file").addEventListener("change", async ev => {
      const f = ev.target.files && ev.target.files[0]; 
      if(!f) return;
      const reader = new FileReader();
      reader.onload = async e => {
        try {
          const parsed = JSON.parse(e.target.result);
          if(!Array.isArray(parsed)) { 
            alert("Ung√ºltiges Format: JSON-Array erwartet."); 
            return; 
          }
          if(confirm("Gerichte ersetzen? OK = ersetzen, Abbrechen = anh√§ngen (keine Duplikate nach Name).")) {
            const normalized = parsed.map(p=>({ id: uid(), name: String(p.name||"").trim(), price: isFinite(Number(p.price))?Number(p.price):0, desc: p.desc||"", tags: p.tags||"" })).filter(Boolean);
            await updateDishes(normalized, true);
            alert("Gerichte ersetzt (importiert).");
          } else {
            const existing = getDishesLocal(); 
            const existingNames = new Set(existing.map(d => d.name.toLowerCase()));
            const toAppend = [];
            for(const p of parsed) { 
              const name = String(p.name||"").trim(); 
              if(!name) continue; 
              if(existingNames.has(name.toLowerCase())) continue; 
              toAppend.push({ id: uid(), name, price: isFinite(Number(p.price))?Number(p.price):0, desc: p.desc||"", tags: p.tags||"" }); 
            }
            if(toAppend.length) { 
              await updateDishes(existing.concat(toAppend), true); 
              alert(`Importiert und angeh√§ngt: ${toAppend.length} neue Gerichte.`); 
            } else {
              alert("Keine neuen Gerichte zum Anh√§ngen gefunden.");
            }
          }
          ev.target.value = "";
          renderDishList(); 
          renderClient(); 
        } catch(err) { 
          console.error(err); 
          alert("Fehler beim Einlesen der Datei."); 
        }
      };
      reader.readAsText(f);
    });

    // ---------- Orders: create, render, set status, delete ----------
    domCache.orderForm.addEventListener("submit", async e => {
      e.preventDefault();
      const dishesAll = getDishesLocal();
      const checked = Array.from(document.querySelectorAll("#client-dish-picker input[type=checkbox]:checked"))
        .map(cb => dishesAll.find(d => d.id === cb.value)).filter(Boolean);
      if(!checked.length) { 
        alert("Bitte mindestens ein Gericht ausw√§hlen."); 
        return; 
      }
      const customerName = domCache.customerName.value.trim();
      if(!customerName) { 
        alert("Bitte deinen Namen angeben."); 
        return; 
      }
      const arr = getOrdersLocal();
      const order = { 
        id: uid(), 
        dishes: checked.map(d => ({id:d.id, name:d.name, price:d.price||0})), 
        destination: "N/A", 
        customerName, 
        status: "open", 
        createdAt: new Date().toISOString() 
      };
      arr.unshift(order);
      await updateOrders(arr, true);
      domCache.orderForm.reset();
      Array.from(document.querySelectorAll("#client-dish-picker input[type=checkbox]")).forEach(cb => cb.checked=false);
      
      // Show notification for new order
      showNotification('Neue Bestellung eingegangen!', `Von: ${customerName}\nGerichte: ${checked.map(d => d.name).join(', ')}`);
      
      alert("Bestellung wurde √ºbermittelt.");
    });

    // render admin orders: only last 48h
    function renderOrders() {
      const all = getOrdersLocal();
      const now = Date.now(); 
      const cutoff = now - 48*60*60*1000;
      const recent = all.filter(o => { 
        try { 
          return new Date(o.createdAt).getTime() >= cutoff; 
        } catch(e) { 
          return false; 
        }
      });
      
      if(!recent.length) { 
        domCache.orderList.innerHTML = '<div class="empty">Noch keine Bestellungen in den letzten 48 Stunden.</div>';
        return; 
      }
      
      // Use DocumentFragment for better performance
      const fragment = document.createDocumentFragment();
      
      recent.forEach(o => {
        const created = new Date(o.createdAt); 
        const meta = `${created.toLocaleDateString()} ${created.toLocaleTimeString()}`;
        const statusLabel = o.status === "done" ? "erledigt" : (o.status === "in_progress" ? "in Arbeit" : "offen");
        const badge = o.status === "done" ? "badge ok" : (o.status === "in_progress" ? "badge warn" : "badge");
        const item = createEl("div",{class:"item"},
          createEl("div",{class:"item-header"},
            createEl("strong",{}, `${o.customerName}`),
            createEl("div",{}, createEl("span",{class:badge}, statusLabel))
          ),
          createEl("div",{class:"muted"}, `Bestellt am ${meta}`),
          o.destination && o.destination !== "N/A" ? createEl("div",{}, `Wohin: ${o.destination}`) : "",
          (function() { 
            const ul = createEl("ul",{class:"inline-list"}); 
            for(const d of o.dishes) ul.appendChild(createEl("li",{}, `${d.name}${(typeof d.price==='number' && d.price>0)?` (${d.price.toFixed(2)} ‚Ç¨)`:""}`)); 
            return ul; 
          })(),
          createEl("div",{class:"actions"},
            createEl("button",{class:"ok", onclick: async () => { await setOrderStatus(o.id,"in_progress"); }}, "In Arbeit"),
            createEl("button",{class:"warn", onclick: async () => { await setOrderStatus(o.id,"done"); }}, "Abhaken (erledigt)"),
            createEl("button",{class:"primary", onclick: async () => { await setOrderStatus(o.id,"open"); }}, "Zur√ºck auf 'offen'"),
            createEl("button",{class:"danger", onclick: async () => { if(confirm("Bestellung l√∂schen?")) await deleteOrder(o.id); }}, "L√∂schen")
          )
        );
        fragment.appendChild(item);
      });
      
      domCache.orderList.innerHTML = '';
      domCache.orderList.appendChild(fragment);
    }

    async function setOrderStatus(id, status) {
      const arr = getOrdersLocal();
      const i = arr.findIndex(x => x.id === id);
      if(i === -1) return;
      arr[i].status = status;
      await updateOrders(arr, true);
      renderOrders();
    }
    
    async function deleteOrder(id) {
      const arr = getOrdersLocal().filter(x=>x.id!==id);
      await updateOrders(arr, true);
      renderOrders();
    }

    document.getElementById("clear-orders-btn").addEventListener("click", async () => { 
      if(confirm("Alle Bestellungen l√∂schen?")) { 
        await updateOrders([], true); 
        renderOrders(); 
      } 
    });
    
    document.getElementById("clear-done-btn").addEventListener("click", async () => { 
      const remaining = getOrdersLocal().filter(o=>o.status !== "done"); 
      await updateOrders(remaining, true); 
      renderOrders(); 
    });

    // ---------- Notification helper ----------
    async function showNotification(title, body) {
      if (Notification.permission === 'granted') {
        new Notification(title, {
          body: body,
          icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üçï</text></svg>'
        });
      } else if (Notification.permission !== 'denied') {
        const permission = await Notification.requestPermission();
        if (permission === 'granted') {
          new Notification(title, {
            body: body,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üçï</text></svg>'
          });
        }
      }
    }

    // ---------- Polling: keep admin up-to-date, using normalization ----------
    let pollTimer = null;
    
    async function refreshOrdersFromRemote() {
      if(!REMOTE_SYNC_ORDERS) return;
      try {
        const raw = await fetchBinLatest(JSONBIN_ORDERS_ID);
        const normalized = normalizeOrders(raw);
        if(Array.isArray(normalized)) {
          const oldOrders = getOrdersLocal();
          const oldOrderIds = new Set(oldOrders.map(o => o.id));
          const newOrders = normalized.filter(order => !oldOrderIds.has(order.id));
          
          setOrdersLocal(normalized);
          renderOrders();
          
          if(newOrders.length > 0) {
            for(const order of newOrders) {
              showNotification('Neue Bestellung eingegangen!', `Von: ${order.customerName}\nGerichte: ${order.dishes.map(d => d.name).join(', ')}`);
            }
          }
        }
      } catch(e) { 
        console.warn("refreshOrdersFromRemote:", e); 
      }
    }
    
    function startPolling() { 
      if(pollTimer) clearInterval(pollTimer); 
      pollTimer = setInterval(refreshOrdersFromRemote, POLL_INTERVAL_MS); 
    }

    // ---------- Initialization ----------
    (async function init() {
      initDomCache(); // Initialize DOM cache first
      
      // Load dishes and orders asynchronously
      const [dishesLoaded, ordersLoaded] = await Promise.allSettled([
        (async () => {
          if(REMOTE_SYNC_DISHES) {
            try {
              const rawD = await fetchBinLatest(JSONBIN_DISHES_ID);
              if(Array.isArray(rawD) && rawD.length) setDishesLocal(rawD);
              else {
                const local = getDishesLocal();
                if(local.length) await putBin(JSONBIN_DISHES_ID, local);
              }
            } catch(e) { 
              console.warn("dishes remote load failed:", e); 
            }
          }
        })(),
        (async () => {
          if(REMOTE_SYNC_ORDERS) {
            try {
              const rawO = await fetchBinLatest(JSONBIN_ORDERS_ID);
              const normalized = normalizeOrders(rawO);
              if(Array.isArray(normalized) && normalized.length) {
                const oldOrders = getOrdersLocal();
                const oldOrderIds = new Set(oldOrders.map(o => o.id));
                const newOrders = normalized.filter(order => !oldOrderIds.has(order.id));
                
                setOrdersLocal(normalized);
                
                if(newOrders.length > 0) {
                  for(const order of newOrders) {
                    showNotification('Neue Bestellung eingegangen!', `Von: ${order.customerName}\nGerichte: ${order.dishes.map(d => d.name).join(', ')}`);
                  }
                }
              } else {
                const local = getOrdersLocal();
                if(local.length) await putBin(JSONBIN_ORDERS_ID, local);
              }
            } catch(e) { 
              console.warn("orders remote load failed:", e); 
            }
          }
        })()
      ]);

      // ensure demo dishes exist
      const localD = getDishesLocal();
      if(!localD.length) {
        const demo = [
          {id:uid(),name:"Margherita",price:7.5,desc:"Tomate, Mozzarella, Basilikum",tags:"vegetarisch"},
          {id:uid(),name:"Spaghetti Bolognese",price:9.9,desc:"Hausgemachte So√üe",tags:""},
          {id:uid(),name:"Rotes Thai Curry",price:11.5,desc:"Mit Gem√ºse & Kokos",tags:"scharf,vegan"}
        ];
        await updateDishes(demo, true);
      }

      renderDishList();
      renderClient();
      renderOrders();
      
      if(REMOTE_SYNC_ORDERS) startPolling();
      
      if(!location.hash) location.replace("#/client");
      window.addEventListener("hashchange", onHashChange);
      onHashChange();
    })();

    // ---------- routing helper ----------
    function onHashChange() {
      const path = location.hash.replace("#","") || "/client";
      if(path === "/admin" || path === "admin") {
        showAdmin();
      } else showClient();
    }
    
    function showClient() { 
      domCache.viewClient.hidden = false; 
      domCache.viewAdmin.hidden = true; 
      domCache.linkClient.classList.add("active"); 
      domCache.linkAdmin.classList.remove("active"); 
    }
    
    function showAdmin() { 
      domCache.viewClient.hidden = true; 
      domCache.viewAdmin.hidden = false; 
      domCache.linkClient.classList.remove("active"); 
      domCache.linkAdmin.classList.add("active"); 
      renderOrders(); 
    }
  </script>
</body>
</html>