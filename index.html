<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerichte – Client & Admin (Single File)</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --accent: #22d3ee;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --ok: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(1200px 800px at 10% 10%, #0b1226 0, var(--bg) 60%);
      color: var(--text);
    }
    .wrap { max-width: 1000px; margin: 0 auto; padding: 24px; }
    header {
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
      margin-bottom: 16px;
    }
    .brand { font-weight: 700; letter-spacing: .2px; display: flex; gap: 10px; align-items: center;}
    .brand-badge {
      width: 28px; height: 28px; border-radius: 8px; background: linear-gradient(135deg, #22d3ee, #22c55e);
      box-shadow: 0 0 20px rgba(34, 211, 238, .35);
    }
    nav { display: flex; gap: 8px; }
    a.btn {
      text-decoration: none; color: var(--text);
      padding: 10px 14px; border-radius: 12px; background: #0b1220; border: 1px solid #1f2a44;
    }
    a.btn.active, a.btn:hover { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(34,211,238,.15) inset; }
    .panel {
      background: linear-gradient(180deg, var(--panel) 0, var(--panel-2) 100%);
      border: 1px solid #243048; border-radius: 16px; padding: 18px; margin: 12px 0;
      box-shadow: 0 10px 30px rgba(2,6,23,.35);
    }
    h1,h2,h3 { margin: 6px 0 10px; }
    h1 { font-size: 26px; }
    h2 { font-size: 20px; color: var(--accent); }
    .grid { display: grid; gap: 14px; }
    @media (min-width: 900px) { .grid-2 { grid-template-columns: 1fr 1fr; } }
    label { font-size: 14px; color: var(--muted); display:block; margin-bottom:6px; }
    input, textarea, select {
      width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid #2a385a;
      background: #0b1220; color: var(--text); outline: none;
    }
    textarea { min-height: 72px; resize: vertical; }
    .row { display: flex; gap: 10px; }
    .row > * { flex: 1; }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    button {
      padding: 10px 14px; border-radius: 12px; border: 1px solid #2a385a;
      background: #0b1220; color: var(--text); cursor: pointer;
    }
    button.primary { border-color: var(--accent); }
    button.ok { border-color: var(--ok); }
    button.warn { border-color: var(--warn); }
    button.danger { border-color: var(--danger); }
    .muted { color: var(--muted); font-size: 14px; }
    .list { display: grid; gap: 10px; }
    .item {
      display: grid; gap: 6px; padding: 12px; border: 1px solid #25314c; border-radius: 14px;
      background: #0b1220;
    }
    .item-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .badge {
      padding: 4px 8px; border-radius: 999px; border: 1px solid #2a385a; font-size: 12px;
    }
    .badge.ok { border-color: var(--ok); background: rgba(34,197,94,0.06); }
    .badge.warn { border-color: var(--warn); background: rgba(245,158,11,0.06); }
    .badge.danger { border-color: var(--danger); background: rgba(239,68,68,0.06); }
    .empty {
      padding: 16px; border: 1px dashed #2a385a; border-radius: 12px; color: var(--muted);
      text-align: center;
    }
    .footer { margin-top: 24px; color: var(--muted); font-size: 12px; text-align: center; }
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .dish-checkbox-row { display:flex; align-items:center; gap:10px; padding:8px; border-radius:10px; background:transparent; border:1px solid transparent; }
    .dish-checkbox-row input[type="checkbox"] { width:18px; height:18px; }
    .dish-checkbox-row label { cursor:pointer; }
    ul.inline-list { margin:0; padding-left:18px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="brand-badge" aria-hidden="true"></div>
        <div>
          <div style="font-size:14px;color:var(--muted)">Single-File App</div>
          <div style="font-size:18px">Gerichte – Client & Admin</div>
        </div>
      </div>
      <nav>
        <a href="#/client" id="link-client" class="btn">Client</a>
      </nav>
    </header>

    <!-- Client View -->
    <section id="view-client" class="panel" hidden>
      <h1>Bestellung aufgeben</h1>
      <div class="grid grid-2">
        <div class="panel">
          <h2>1) Gerichte wählen</h2>
          <div id="client-dish-picker"></div>
        </div>
        <div class="panel">
          <h2>2) Wohin & Name</h2>
          <form id="order-form">
            <label for="customer-name">Name</label>
            <input id="customer-name" name="customer-name" placeholder="Max Mustermann" required />

            <label for="destination">Wohin</label>
            <input id="destination" name="destination" placeholder="z. B. Musterstraße 12, 12345 Musterstadt" required />
            <div class="actions" style="margin-top:10px">
              <button class="primary" type="submit">Bestellen</button>
              <button type="reset" id="order-reset-btn">Zurücksetzen</button>
            </div>
            <div class="hint">Nach Absenden erscheint deine Bestellung im Admin-Bereich.</div>
          </form>
        </div>
      </div>
    </section>

    <!-- Admin View -->
    <section id="view-admin" class="panel" hidden>
      <h1>Admin</h1>
      <div class="grid grid-2">
        <div class="panel">
          <h2>Gerichte verwalten</h2>
          <form id="dish-form">
            <label for="dish-name">Gericht</label>
            <input id="dish-name" placeholder="z. B. Spaghetti Bolognese" required />
            <div class="row">
              <div>
                <label for="dish-price">Preis (€)</label>
                <input id="dish-price" type="number" step="0.01" min="0" placeholder="9.90" />
              </div>
              <div>
                <label for="dish-tags">Tags (optional)</label>
                <input id="dish-tags" placeholder="vegan, scharf, ..."/>
              </div>
            </div>
            <label for="dish-desc">Beschreibung (optional)</label>
            <textarea id="dish-desc" placeholder="Kurzbeschreibung..."></textarea>
            <div class="actions" style="margin-top:10px">
              <button class="primary" type="submit">Gericht anlegen</button>
              <button type="button" id="seed-btn">Demo-Daten füllen</button>
              <button class="warn" type="button" id="clear-dishes-btn">Alle Gerichte löschen</button>
            </div>
          </form>

          <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
            <button id="export-dishes-btn">Gerichte exportieren</button>
            <button id="import-dishes-btn">Gerichte importieren</button>
            <input id="import-dishes-file" type="file" accept="application/json" style="display:none" />
            <div class="muted" style="align-self:center; font-size:13px;">Export/Import synchronisiert manuell zwischen Geräten.</div>
          </div>

          <div id="dish-list" class="list" style="margin-top:10px"></div>
        </div>
        <div class="panel">
          <h2>Eingehende Bestellungen (letzte 48 Stunden)</h2>
          <div class="actions" style="margin-bottom:8px">
            <button class="warn" id="clear-done-btn" type="button">Erledigte entfernen</button>
            <button class="danger" id="clear-orders-btn" type="button">Alle Bestellungen löschen</button>
          </div>
          <div id="order-list" class="list"></div>
          <div class="hint">Admin aktualisiert Bestellungen automatisch (Polling). Bestellungen werden remote in JSONBin gespeichert.</div>
        </div>
      </div>
    </section>

    <div class="footer">
      Routen: <code>#/client</code> und <code>#/admin</code> • Single File • GitHub Pages kompatibel
    </div>
  </div>

  <script>
    // -------------------- CONFIG --------------------
    const REMOTE_SYNC_DISHES = true;
    const REMOTE_SYNC_ORDERS = true;
    const JSONBIN_KEY = "$2a$10$N/2gxnECUzbO8QCffVQ7Ye6N5Oare5DGjQCPaTkkcovABoafVICSS";
    const JSONBIN_DISHES_ID = "68a5d4feae596e708fcf10d3";
    const JSONBIN_ORDERS_ID = "68a5e44a43b1c97be9236b9e";
    const ADMIN_PASSWORD = "admin123";
    const POLL_INTERVAL_MS = 5000;
    // ------------------------------------------------

    const $ = (s, r=document) => r.querySelector(s);
    const el = (tag, attrs={}, ...children) => {
      const n = document.createElement(tag);
      for (const [k,v] of Object.entries(attrs)) {
        if (k === "class") n.className = v;
        else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
        else if (v !== undefined && v !== null) n.setAttribute(k, v);
      }
      for (const c of children) n.append(c instanceof Node ? c : document.createTextNode(c));
      return n;
    };
    const uid = () => Math.random().toString(36).slice(2,10) + Date.now().toString(36);

    // ---------- local storage helpers ----------
    function getDishesLocal(){ try { return JSON.parse(localStorage.getItem("app.dishes.v1")||"[]"); } catch(e){ return []; } }
    function setDishesLocal(a){ localStorage.setItem("app.dishes.v1", JSON.stringify(a)); }
    function getOrdersLocal(){ try { return JSON.parse(localStorage.getItem("app.orders.v1")||"[]"); } catch(e){ return []; } }
    function setOrdersLocal(a){ localStorage.setItem("app.orders.v1", JSON.stringify(a)); }

    // ---------- JSONBin helpers ----------
    async function fetchBinLatest(binId){
      if(!binId) return null;
      const url = `https://api.jsonbin.io/v3/b/${binId}/latest`;
      const h = { "X-Master-Key": JSONBIN_KEY };
      const res = await fetch(url, { headers: h });
      if(!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();
      return json.record;
    }
    async function putBin(binId, data){
      if(!binId) throw new Error("no bin id");
      const url = `https://api.jsonbin.io/v3/b/${binId}`;
      const headers = { "Content-Type":"application/json", "X-Master-Key": JSONBIN_KEY, "X-Bin-Versioning": "false" };
      const res = await fetch(url, { method: "PUT", headers, body: JSON.stringify(data) });
      if(!res.ok){
        const t = await res.text().catch(()=>"");
        throw new Error("HTTP " + res.status + " " + t);
      }
      return await res.json();
    }

    // ---------- Normalizer for orders (accept many shapes) ----------
    function normalizeOrders(raw){
      // raw can be: array, object with key orders/data/items, or single obj
      let arr = null;
      if(!raw) return [];
      if(Array.isArray(raw)) arr = raw;
      else if(typeof raw === "object"){
        // if it directly has a list property
        const keys = Object.keys(raw);
        // common keys
        if(Array.isArray(raw.orders)) arr = raw.orders;
        else if(Array.isArray(raw.data)) arr = raw.data;
        else if(Array.isArray(raw.items)) arr = raw.items;
        else {
          // find first array value
          for(const k of keys){
            if(Array.isArray(raw[k])){ arr = raw[k]; break; }
          }
        }
        // if still null, maybe it's a single order object -> wrap
        if(arr === null) arr = [raw];
      } else {
        return [];
      }

      // map each entry to canonical schema
      const normalized = arr.map((o)=>{
        if(!o || typeof o !== 'object') return null;
        // possible fields for name: customerName, name, customer.name, customer
        let customerName = o.customerName || o.name || o.customer || (o.customer && (o.customer.name||o.customer.customerName)) || "";
        if(typeof customerName === 'object'){ // e.g. customer object
          customerName = customerName.name || customerName.customerName || "";
        }
        // destination fields
        let destination = o.destination || o.address || o.wohin || (o.customer && o.customer.address) || "";
        if(typeof destination === 'object') destination = JSON.stringify(destination);
        // dishes: items/products/dishes
        let items = o.dishes || o.items || o.products || o.orderItems || [];
        if(!Array.isArray(items)){
          // maybe items is object with array inside
          if(typeof items === 'object'){
            const possible = Object.values(items).find(v=>Array.isArray(v));
            items = possible || [];
          } else {
            items = [];
          }
        }
        // normalize items to {name, price}
        const normItems = items.map(it=>{
          if(!it) return null;
          if(typeof it === 'string') return { name: it, price: 0 };
          if(typeof it === 'object'){
            const name = it.name || it.title || it.item || it.product || "";
            const price = (isFinite(Number(it.price))? Number(it.price) : (isFinite(Number(it.cost))?Number(it.cost):0));
            return { name: name || JSON.stringify(it).slice(0,40), price };
          }
          return null;
        }).filter(Boolean);

        // id
        let id = o.id || o._id || o.orderId || (o.customer && o.customer.id) || null;
        if(!id) id = uid();
        // status normalization
        let status = (o.status || o.state || o.orderStatus || "open") + "";
        status = status.toLowerCase();
        if(status === "in_arbeit" || status === "in arbeit" || status === "inprogress" || status === "in progress" || status === "in_progress" || status === "processing") status = "in_progress";
        else if(status === "done" || status === "erledigt" || status === "completed" || status === "finished") status = "done";
        else status = "open";

        // createdAt
        let createdAt = o.createdAt || o.timestamp || o.time || o.created_at || o.date || new Date().toISOString();
        try { if(typeof createdAt === 'number') createdAt = new Date(createdAt).toISOString(); else createdAt = new Date(createdAt).toISOString(); } catch(e){ createdAt = new Date().toISOString(); }

        return {
          id: String(id),
          customerName: String(customerName || "").trim(),
          destination: String(destination || "").trim(),
          dishes: normItems,
          status,
          createdAt
        };
      }).filter(Boolean);

      return normalized;
    }

    // ---------- update helpers (local + optional remote) ----------
    async function updateDishes(arr, pushRemote = true){
      setDishesLocal(arr);
      if(REMOTE_SYNC_DISHES && pushRemote){
        try{ await putBin(JSONBIN_DISHES_ID, arr); } catch(e){ console.warn("putBin dishes failed", e); alert("Warnung: Gerichte remote nicht gespeichert."); }
      }
    }
    async function updateOrders(arr, pushRemote = true){
      setOrdersLocal(arr);
      if(REMOTE_SYNC_ORDERS && pushRemote){
        try{ await putBin(JSONBIN_ORDERS_ID, arr); } catch(e){ console.warn("putBin orders failed", e); alert("Warnung: Bestellungen remote nicht gespeichert."); }
      }
    }

    // ---------- rendering / UI logic (keeps layout) ----------
    function renderClient(){
      const mount = $("#client-dish-picker");
      mount.innerHTML = "";
      const dishes = getDishesLocal();
      if(!dishes.length){ mount.append(el("div",{class:"empty"},"Noch keine Gerichte verfügbar. Bitte Admin fragen, welche anzulegen.")); return; }
      for(const d of dishes){
        const row = el("div",{class:"dish-checkbox-row"});
        const cb = el("input",{type:"checkbox", value:d.id, id:"dish-"+d.id});
        const label = el("label",{for:"dish-"+d.id}, `${d.name}${d.price?` – ${d.price.toFixed(2)} €`:""}`);
        row.append(cb,label);
        mount.append(row);
        if(d.desc) mount.append(el("div",{class:"muted", style:"font-size:13px;margin-left:28px;"}, d.desc));
      }
    }

    // dish management (same UI)
    $("#dish-form").addEventListener("submit", async e=>{
      e.preventDefault();
      const name = $("#dish-name").value.trim();
      const price = parseFloat($("#dish-price").value);
      const desc = $("#dish-desc").value.trim();
      const tags = $("#dish-tags").value.trim();
      if(!name){ alert("Gerichtsname erforderlich."); return; }
      const arr = getDishesLocal();
      const existing = arr.findIndex(x => x.name.toLowerCase() === name.toLowerCase());
      if(existing >= 0){
        arr[existing] = { id: arr[existing].id || uid(), name, price: isFinite(price)?price:0, desc, tags };
      } else {
        arr.unshift({ id: uid(), name, price: isFinite(price)?price:0, desc, tags });
      }
      await updateDishes(arr, true);
      e.target.reset();
      renderDishList();
      renderClient();
    });
    $("#seed-btn").addEventListener("click", async ()=>{ const local = getDishesLocal(); if(local.length) return; const demo = [{id:uid(),name:"Margherita",price:7.5,desc:"Tomate, Mozzarella, Basilikum",tags:"vegetarisch"},{id:uid(),name:"Spaghetti Bolognese",price:9.9,desc:"Hausgemachte Soße",tags:""},{id:uid(),name:"Rotes Thai Curry",price:11.5,desc:"Mit Gemüse & Kokos",tags:"scharf,vegan"}]; await updateDishes(demo,true); renderDishList(); renderClient(); });
    $("#clear-dishes-btn").addEventListener("click", async ()=>{ if(confirm("Alle Gerichte wirklich löschen?")){ await updateDishes([], true); renderDishList(); renderClient(); }});

    function renderDishList(){
      const mount = $("#dish-list"); mount.innerHTML = "";
      const arr = getDishesLocal();
      if(!arr.length){ mount.append(el("div",{class:"empty"},"Keine Gerichte vorhanden.")); return; }
      for(const d of arr){
        const item = el("div",{class:"item"},
          el("div",{class:"item-header"}, el("strong",{}, d.name), el("div",{}, d.price?el("span",{class:"badge"}, `${d.price.toFixed(2)} €`):"")),
          d.desc?el("div",{class:"muted"}, d.desc):"",
          d.tags?el("div",{class:"muted"}, `Tags: ${d.tags}`):"",
          el("div",{class:"actions"}, el("button",{class:"danger", onclick: async ()=>{ await deleteDish(d.id); }}, "Löschen"))
        );
        mount.append(item);
      }
    }
    async function deleteDish(id){ const remaining = getDishesLocal().filter(d=>d.id!==id); await updateDishes(remaining,true); renderDishList(); renderClient(); }

    // export/import dishes (unchanged)
    $("#export-dishes-btn").addEventListener("click", ()=>{ const data = getDishesLocal(); const blob = new Blob([JSON.stringify(data,null,2)],{type:"application/json"}); const url = URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="gerichte_export_"+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')+".json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });
    $("#import-dishes-btn").addEventListener("click", ()=>$("#import-dishes-file").click());
    $("#import-dishes-file").addEventListener("change", async ev=>{
      const f = ev.target.files && ev.target.files[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = async e=>{
        try{
          const parsed = JSON.parse(e.target.result);
          if(!Array.isArray(parsed)){ alert("Ungültiges Format: JSON-Array erwartet."); return; }
          if(confirm("Gerichte ersetzen? OK = ersetzen, Abbrechen = anhängen (keine Duplikate nach Name).")){
            const normalized = parsed.map(p=>({ id: uid(), name: String(p.name||"").trim(), price: isFinite(Number(p.price))?Number(p.price):0, desc: p.desc||"", tags: p.tags||"" })).filter(Boolean);
            await updateDishes(normalized, true);
            alert("Gerichte ersetzt (importiert).");
          } else {
            const existing = getDishesLocal(); const existingNames = new Set(existing.map(d=>d.name.toLowerCase()));
            const toAppend = [];
            for(const p of parsed){ const name = String(p.name||"").trim(); if(!name) continue; if(existingNames.has(name.toLowerCase())) continue; toAppend.push({ id: uid(), name, price: isFinite(Number(p.price))?Number(p.price):0, desc: p.desc||"", tags: p.tags||"" }); }
            if(toAppend.length){ await updateDishes(existing.concat(toAppend), true); alert(`Importiert und angehängt: ${toAppend.length} neue Gerichte.`); } else alert("Keine neuen Gerichte zum Anhängen gefunden.");
          }
          ev.target.value="";
          renderDishList(); renderClient();
        }catch(err){ console.error(err); alert("Fehler beim Einlesen der Datei."); }
      };
      reader.readAsText(f);
    });

    // ---------- Orders: create, render, set status, delete ----------
    $("#order-form").addEventListener("submit", async e=>{
      e.preventDefault();
      const dishesAll = getDishesLocal();
      const checked = Array.from(document.querySelectorAll("#client-dish-picker input[type=checkbox]:checked"))
        .map(cb => dishesAll.find(d => d.id === cb.value)).filter(Boolean);
      if(!checked.length){ alert("Bitte mindestens ein Gericht auswählen."); return; }
      const customerName = $("#customer-name").value.trim();
      if(!customerName){ alert("Bitte deinen Namen angeben."); return; }
      const destination = $("#destination").value.trim();
      if(!destination){ alert("Bitte Feld 'Wohin' ausfüllen."); return; }
      const arr = getOrdersLocal();
      const order = { id: uid(), dishes: checked.map(d=>({id:d.id,name:d.name,price:d.price||0})), destination, customerName, status: "open", createdAt: new Date().toISOString() };
      arr.unshift(order);
      await updateOrders(arr, true); // save local + remote
      e.target.reset();
      Array.from(document.querySelectorAll("#client-dish-picker input[type=checkbox]")).forEach(cb=>cb.checked=false);
      alert("Bestellung wurde übermittelt.");
    });

    // render admin orders: only last 48h
    function renderOrders(){
      const mount = $("#order-list"); mount.innerHTML = "";
      const all = getOrdersLocal();
      const now = Date.now(); const cutoff = now - 48*60*60*1000;
      const recent = all.filter(o => { try { return new Date(o.createdAt).getTime() >= cutoff; } catch(e){ return false; }});
      if(!recent.length){ mount.append(el("div",{class:"empty"},"Noch keine Bestellungen in den letzten 48 Stunden.")); return; }
      recent.forEach(o=>{
        const created = new Date(o.createdAt); const meta = `${created.toLocaleDateString()} ${created.toLocaleTimeString()}`;
        const statusLabel = o.status === "done" ? "erledigt" : (o.status === "in_progress" ? "in Arbeit" : "offen");
        const badge = o.status === "done" ? "badge ok" : (o.status === "in_progress" ? "badge warn" : "badge");
        const item = el("div",{class:"item"},
          el("div",{class:"item-header"},
            el("strong",{}, `${o.customerName}`),
            el("div",{}, el("span",{class:badge}, statusLabel))
          ),
          el("div",{class:"muted"}, `Bestellt am ${meta}`),
          el("div",{}, `Wohin: ${o.destination}`),
          (function(){ const ul = el("ul",{class:"inline-list"}); for(const d of o.dishes) ul.append(el("li",{}, `${d.name}${(typeof d.price==='number' && d.price>0)?` (${d.price.toFixed(2)} €)`:""}`)); return ul; })(),
          el("div",{class:"actions"},
            el("button",{class:"ok", onclick: async ()=>{ await setOrderStatus(o.id,"in_progress"); }}, "In Arbeit"),
            el("button",{class:"warn", onclick: async ()=>{ await setOrderStatus(o.id,"done"); }}, "Abhaken (erledigt)"),
            el("button",{class:"primary", onclick: async ()=>{ await setOrderStatus(o.id,"open"); }}, "Zurück auf 'offen'"),
            el("button",{class:"danger", onclick: async ()=>{ if(confirm("Bestellung löschen?")) await deleteOrder(o.id); }}, "Löschen")
          )
        );
        mount.append(item);
      });
    }

    async function setOrderStatus(id, status){
      const arr = getOrdersLocal();
      const i = arr.findIndex(x => x.id === id);
      if(i === -1) return;
      arr[i].status = status;
      await updateOrders(arr, true);
      renderOrders();
    }
    async function deleteOrder(id){
      const arr = getOrdersLocal().filter(x=>x.id!==id);
      await updateOrders(arr, true);
      renderOrders();
    }

    $("#clear-orders-btn").addEventListener("click", async ()=>{ if(confirm("Alle Bestellungen löschen?")){ await updateOrders([], true); renderOrders(); }});
    $("#clear-done-btn").addEventListener("click", async ()=>{ const remaining = getOrdersLocal().filter(o=>o.status !== "done"); await updateOrders(remaining, true); renderOrders(); });

    // ---------- Polling: keep admin up-to-date, using normalization ----------
    let pollTimer = null;
    async function refreshOrdersFromRemote(){
      if(!REMOTE_SYNC_ORDERS) return;
      try{
        const raw = await fetchBinLatest(JSONBIN_ORDERS_ID);
        const normalized = normalizeOrders(raw);
        // if normalized array is non-empty, adopt it as authoritative
        if(Array.isArray(normalized)){
          setOrdersLocal(normalized);
          renderOrders();
        }
      }catch(e){ console.warn("refreshOrdersFromRemote:", e); }
    }
    function startPolling(){ if(pollTimer) clearInterval(pollTimer); pollTimer = setInterval(refreshOrdersFromRemote, POLL_INTERVAL_MS); }

    // ---------- Initialization ----------
    (async function init(){
      // try load remote dishes
      if(REMOTE_SYNC_DISHES){
        try{
          const rawD = await fetchBinLatest(JSONBIN_DISHES_ID);
          if(Array.isArray(rawD) && rawD.length) setDishesLocal(rawD);
          else {
            const local = getDishesLocal();
            if(local.length) await putBin(JSONBIN_DISHES_ID, local);
          }
        }catch(e){ console.warn("dishes remote load failed:", e); }
      }
      // try load remote orders (normalize)
      if(REMOTE_SYNC_ORDERS){
        try{
          const rawO = await fetchBinLatest(JSONBIN_ORDERS_ID);
          const normalized = normalizeOrders(rawO);
          if(Array.isArray(normalized) && normalized.length) setOrdersLocal(normalized);
          else {
            const local = getOrdersLocal();
            if(local.length) await putBin(JSONBIN_ORDERS_ID, local);
          }
        }catch(e){ console.warn("orders remote load failed:", e); }
      }

      // ensure demo dishes exist
      const localD = getDishesLocal();
      if(!localD.length){
        const demo = [{id:uid(),name:"Margherita",price:7.5,desc:"Tomate, Mozzarella, Basilikum",tags:"vegetarisch"},{id:uid(),name:"Spaghetti Bolognese",price:9.9,desc:"Hausgemachte Soße",tags:""},{id:uid(),name:"Rotes Thai Curry",price:11.5,desc:"Mit Gemüse & Kokos",tags:"scharf,vegan"}];
        await updateDishes(demo, true);
      }

      renderDishList();
      renderClient();
      renderOrders();
      if(REMOTE_SYNC_ORDERS) startPolling();
      if(!location.hash) location.replace("#/client");
      window.addEventListener("hashchange", onHashChange);
      onHashChange();
    })();

    // ---------- routing helper ----------
    function onHashChange(){
      const path = location.hash.replace("#","") || "/client";
      if(path === "/admin" || path === "admin") {
        // require pw
        const pw = prompt("Admin-Passwort eingeben:");
        if(pw === ADMIN_PASSWORD) showAdmin(); else { alert("Zugriff verweigert."); location.replace("#/client"); }
      } else showClient();
    }
    function showClient(){ $("#view-client").hidden = false; $("#view-admin").hidden = true; $("#link-client").classList.add("active"); }
    function showAdmin(){ $("#view-client").hidden = true; $("#view-admin").hidden = false; $("#link-client").classList.remove("active"); renderOrders(); }

  </script>
</body>
</html>
